{
  "Encoder": "```latex\n\\subsection{Encoder}\n\nThe Encoder is an integral component of our advanced model, leveraging a ResNet architecture to transform raw input images into continuous latent representations. This architecture excels at extracting high-level features while preserving essential information, which is paramount for effective quantization and subsequent image reconstruction.\n\n\\textbf{Input:} The Encoder receives input images structured as tensors with shape \\([B, C, H, W]\\), where \\(B\\) is the batch size, \\(C\\) denotes the number of channels, and \\(H\\) and \\(W\\) represent the height and width of the images, respectively.\n\n\\textbf{Output:} The output from the Encoder consists of latent representations in a tensor of shape \\([B, D, H', W']\\), where \\(D\\) indicates the dimensionality of the latent space, while \\(H'\\) and \\(W'\\) are the spatial dimensions reduced during the encoding process.\n\n\\textbf{Architecture:} The Encoder comprises a sequence of convolutional layers paired with residual blocks, strategically designed to methodically extract and refine features from the input images:\n\\begin{itemize}\n    \\item The initial layer employs 64 filters with a kernel size of 3 and a stride of 2, facilitating downsampling.\n    \\item This is succeeded by a layer with 128 filters, maintaining the same kernel size and stride to further extract features.\n    \\item The final convolutional layer utilizes 256 filters, adhering to the established kernel size and stride configuration.\n\\end{itemize}\n\nEach convolutional layer is followed by batch normalization, enhancing training stability, and activated using the Leaky ReLU function, which fosters non-linearity and increases the model's capacity to capture complex mappings from input images to their latent representations. The inclusion of residual connections not only deepens the learning capacity but also ensures the integration of intricate patterns without compromising the richness of the features.\n\n\\textbf{Workflow:} The operational flow of the Encoder can be outlined as follows:\n\\begin{enumerate}\n    \\item Raw input images are processed through the layered architecture, enabling a hierarchical capture of features at various abstraction levels.\n    \\item Residual blocks are employed at critical points to deepen learning connections, allowing the model to learn complex mappings effectively while reducing spatial dimensions and increasing the depth of feature representations.\n    \\item The resulting latent representations are meticulously prepared for integration with the Vector Quantizer, emphasizing quantization efficiency and preserving crucial feature fidelity necessary for high-quality reconstructions in the Decoder stage.\n\\end{enumerate}\n\nMathematically, we represent the latent representation \\(z_e\\) generated by the Encoder as follows:\n\n\\begin{equation}\nz_e = \\text{Encoder}(x),\n\\end{equation}\n\nwhere \\(x\\) is the input image. Each layer within the Encoder applies a transformation function \\(f(\\cdot)\\), defined as:\n\n\\begin{equation}\nf(x) = \\text{LeakyReLU}\\left(\\text{BatchNorm}\\left(\\text{Conv2D}(x)\\right)\\right).\n\\end{equation}\n\nThis formulation is pivotal for extracting hierarchical features, which are critical for effective representation learning, particularly addressing the challenges of gradient flow during the non-differentiable quantization phase.\n\nTo further enhance the performance of the Encoder, we implement a rotation and rescaling transformation. This optimization aligns the generated latent representations with the codebook quantization embeddings, thus augmenting representation learning efficiency and addressing potential issues like codebook collapse and inefficient embedding usage.\n\nIn our experimental evaluations, the Encoder exhibited a significant reconstruction loss of 0.0098 and a codebook usage rate of 96.8\\% during inference, along with a perplexity of 7950.4. In contrast, the conventional Standard VQ-VAE presented a higher reconstruction loss of 0.0189 and a codebook usage of 78.3\\%, with a perplexity metric of 802.1. These empirical results demonstrate marked advancements across pivotal performance metrics.\n\nIn summary, the robust design of the Encoder plays a critical role in effective representation learning throughout the overall architecture, facilitating high-quality reconstructions achievable by the Decoder. The subsequent sections will elucidate how the Vector Quantizer discretizes the continuous representations produced by the Encoder into distinct embeddings, underscoring its essential contributions to the overall efficiency of the representation process.\n```",
  "Vector Quantizer": "```latex\n\\subsection{Vector Quantizer}\n\nThe Vector Quantizer (VQ) serves as a pivotal element in our architecture, enabling the conversion of continuous latent representations produced by the Encoder into discrete codes. This discretization process not only facilitates efficient data compression but also promotes enhanced alignment between encoded vectors and codebook embeddings, thereby improving performance in critical tasks such as data reconstruction and information retrieval. To further mitigate alignment issues that may arise during quantization, we incorporate a rotation mechanism based on Householder transformations, which optimizes representation quality.\n\n\\subsubsection{Overview of the Vector Quantization Process}\n\nThe VQ operates through a systematic sequence of steps: distance computation, quantization, rotation mechanism application, loss calculation, and exponential moving average (EMA) updates for the codebook embeddings. The input to this module consists of flattened encoded vectors \\( z_e \\) with dimensions \\([B, D]\\), where \\( B \\) denotes the batch size and \\( D \\) the dimensionality of the latent space. The outputs generated by this process include quantized vectors, quantization loss, perplexity, and encoding indices.\n\nThe quantization process can be delineated as follows:\n\n1. **Distance Computation**: The VQ computes the pairwise squared distances between the encoded vectors \\( z_e \\) and codebook embeddings \\( e \\):\n   \\begin{equation}\n   d(i, j) = \\| z_i - e_j \\|^2,\n   \\end{equation}\n   where \\( d(i, j) \\) represents the squared distance between the encoded vector \\( z_i \\) and the codebook embedding \\( e_j \\). This computation is essential for determining the nearest embedding for quantization.\n\n2. **Quantization**: Following the distance calculations, the VQ identifies the nearest codebook embedding for each encoded vector, encoded through a one-hot representation of the corresponding indices. This effectively converts continuous representations into a compact discrete format.\n\n3. **Rotation Mechanism**: To enhance the alignment between encoded vectors and their quantized representations, we implement a rotation transformation defined by the Householder transformation, characterized by:\n   \\begin{equation}\n   R = I - 2 vv^T,\n   \\end{equation}\n   where \\( v \\) is derived from the normalized difference between the process\u2019s encoded vectors \\( z_e \\) and their quantized counterparts \\( q \\). This rotational adjustment is critical in addressing potential misalignment, leading to improved feature extraction quality.\n\n4. **Loss Calculation**: The quantization loss \\( L \\) is computed as a composite function that includes the mean squared error (MSE) between the quantized vectors \\( q \\) and the original encoded vectors \\( z_e \\), alongside a commitment cost term:\n   \\begin{equation}\n   L = \\text{MSE}(q, z_e) + \\beta \\cdot \\text{MSE}(q, z_e^{\\text{detach}}),\n   \\end{equation}\n   where \\( \\beta = 0.25 \\) is a weighting parameter that balances the fidelity of quantized representations with respect to the original encoded signal, thus fostering effective learning dynamics.\n\n5. **Exponential Moving Average (EMA) for Codebook Updates**: To enhance the stability throughout the learning process, the VQ employs an EMA strategy for updating its codebook embeddings. The adaptive formula considers cluster sizes and governs the evolution of the embeddings as follows:\n   \\begin{equation}\n   \\text{ema\\_cluster\\_size} = \\alpha \\cdot \\text{ema\\_cluster\\_size} + (1 - \\alpha) \\cdot \\text{encodings},\n   \\end{equation}\n   where \\( \\alpha = 0.99 \\) is the decay factor utilized to modulate updates to cluster sizes.\n\nThrough the VQ component, we effectively discretize latent representations. The incorporation of mechanisms such as rotation for alignment and structured updates enhances both representation quality and learning efficacy. Our training results demonstrate a reconstruction loss of 0.0098, reflecting high fidelity in data reconstruction, along with a codebook utilization rate of 96.8\\%. In comparison, the traditional Variational Quantized Autoencoder (VQ-VAE) approach yielded a reconstruction loss of 0.0189 and a codebook usage of just 78.3\\%. Moreover, our perplexity measurement of 7950.4 stands in contrast to 802.1 in the canonical setup, conclusively illustrating that our architecture, fortified by the enhanced VQ, significantly boosts representation learning and reconstructive accuracy across diverse datasets, such as CIFAR-10 and ImageNet.\n```",
  "Decoder": "```latex\n\\subsection{Decoder}\n\nThe Decoder is an integral component of our Rotated Vector Quantization (RVQ) framework, designed to reconstruct the original data from quantized vectors produced by the Vector Quantizer. Its primary objectives are to accurately reconstruct input data from its quantized representation and evaluate the reconstruction quality through the assessment of similarity between reconstructed outputs and their original inputs. This evaluation provides valuable insights that are critical for determining the effectiveness of the model architecture and the overall data recovery process.\n\n\\textbf{Input:} The Decoder receives quantized vectors shaped \\([B, D]\\), where \\(B\\) represents the batch size and \\(D\\) denotes the dimensionality of the embedding space, which is set to \\(D = 256\\) in our implementation.\n\n\\textbf{Output:} The output of the Decoder comprises reconstructed data structured as \\([B, C, H, W]\\), with \\(C\\), \\(H\\), and \\(W\\) symbolizing the number of channels, height, and width of the original input data. For instance, in the case of RGB image reconstruction, the output shape is \\([B, 3, H, W]\\).\n\n\\textbf{Workflow:}\n\\begin{enumerate}\n    \\item The decoding process initiates by reshaping the input quantized vectors \\(q\\) to ensure compatibility with subsequent transposed convolutional operations. This initial reshaping step may involve dimensional adjustments that align with the specific convolutional architecture employed within the Decoder.\n    \\item Following the reshaping, the Decoder utilizes a series of transposed convolutional layers. Each layer applies a transposed convolution operation, enriched by batch normalization and a non-linear activation function, specifically Leaky ReLU. This structured approach effectively reconstructs the spatial dimensions of the original data while preserving vital semantic information encoded during the encoding phase. The architecture consists of three primary transposed convolution layers with 128, 64, and 3 filters, respectively, which progressively expand the feature maps.\n    \\item The final transposed convolutional layer modifies the output feature maps to closely match the spatial dimensions of the input data. A Tanh activation function is subsequently applied to ensure that the reconstructed values remain within a defined range, specifically the interval \\([-1, 1]\\). This range is pertinent for applications such as image generation, where pixel values typically reside within these bounds. Furthermore, the Decoder incorporates attention mechanisms with \\(8\\) attention heads, which enhance the model\u2019s ability to focus on critical regions of the data during reconstruction, thus improving representational efficacy.\n\\end{enumerate}\n\nThe architectural design of the Decoder intentionally mirrors that of the Encoder, effectively reversing the downsampling operations conducted by the Encoder. This structural symmetry is crucial for achieving high-fidelity reconstructions, ensuring that the final outputs closely approximate the original input data.\n\nIn our implementation, the Decoder is seamlessly integrated with the vector quantization process, promoting efficient handling of quantized inputs and minimizing reconstruction fidelity degradation. The performance of the Decoder is paramount to the success of the RVQ framework, as it directly influences the quality of the reconstructed outputs.\n\nTo evaluate the quality of reconstruction, various metrics are employed, including Reconstruction Loss, Codebook Usage, and Perplexity. The Reconstruction Loss, calculated as the mean squared error between the original input and the reconstructed output, attained a value of \\(0.0098\\) under rotation transformations, signifying an improvement when compared to a loss of \\(0.0189\\) without rotation. The Codebook Usage was recorded at \\(96.8\\%\\) with rotation enabled, as opposed to \\(78.3\\%\\) without it. Furthermore, the Perplexity measure, indicative of codebook utilization efficiency, stood at \\(7950.4\\) with the rotation mechanism in operation, demonstrating significant advantages over the standard Vector Quantized Variational Autoencoder (VQ-VAE), which exhibited a Perplexity of \\(802.1\\).\n\nAdditionally, we have addressed challenges associated with non-differentiable quantization operations and the risk of codebook collapse through the implementation of custom gradient functions. This strategy ensures robust gradient propagation across the quantization layers, mitigating issues related to codebook underutilization and fostering consistent performance across diverse training scenarios. For our experiments, a learning rate of \\(0.0002\\) was utilized with the AdamW optimizer, across a training duration of \\(300\\) epochs, complemented by a Cosine Annealing Learning Rate scheduler to enhance the optimization process and maintain representation quality.\n\nIn summary, the Decoder not only effectively reconstructs the original data but also plays a pivotal role in thoroughly evaluating the learned representations. This dual functionality significantly bolsters the overall performance of the Rotated Vector Quantization framework.\n```",
  "Gradient Propagation": "```latex\n\\subsection{Gradient Propagation}\n\nGradient propagation is a critical component in the optimization process of our framework, particularly regarding the challenges posed by non-differentiable quantization operations within the Vector Quantization layer. These quantization operations introduce discontinuities that can impede effective backpropagation, necessitating the development of a specialized strategy to ensure robust gradient flow throughout the architecture.\n\nTo address these challenges, we implement a custom gradient function designed specifically for the needs of our model. A central feature of this strategy is the straight-through estimator (STE), which approximates the quantization process as a differentiable operation. This approximation allows gradients to traverse smoothly through quantization layers, effectively preserving essential information and enhancing the learning dynamics between the Encoder and Decoder components of our model.\n\nWe mathematically define the quantized output \\( q \\) as follows:\n\n\\begin{equation}\nq = z_e + (q_{\\text{quantized}} - z_e) \\cdot \\text{detach}\n\\end{equation}\n\nwhere \\( z_e \\) represents the continuous latent representation produced by the Encoder, and \\( q_{\\text{quantized}} \\) is the output from the Vector Quantizer. This expression establishes a crucial connection between the continuous and quantized representations, facilitating effective representation learning and optimizing the overall performance of our framework.\n\nThe gradient propagation process unfolds through several pivotal steps, as described below:\n\n\\begin{enumerate}\n    \\item **Custom Gradient Function**: We define a tailored gradient function that utilizes the straight-through estimator to guide backpropagation through the quantization layers. This function mitigates the barriers posed by non-differentiable quantization techniques, enabling a continuous flow of gradients throughout the optimization process.\n\n    \\item **Backpropagation Mechanics**: The STE creates a pathway for gradient information to flow from the Decoder, through the Vector Quantizer, and back to the Encoder. This augmented gradient flow is essential for coherent learning across the entire architecture, improving interdependencies among components and enhancing overall model performance.\n\n    \\item **Dual Loss Evaluation**: During our optimization process, the Vector Quantizer computes both the commitment loss and reconstruction loss. This dual loss framework enriches the gradient flow and augments learning dynamics by addressing potential issues like codebook collapse and inefficient utilization of codebook entries, which have been previously noted in vector quantization literature. The commitment loss is formulated as follows:\n\n    \\begin{equation}\n    \\mathcal{L}_{\\text{commit}} = \\frac{\\beta}{2} \\lVert z_e - \\text{sg}(q_{\\text{quantized}}) \\rVert^2\n    \\end{equation}\n\n    where \\(\\beta\\) is a hyperparameter that regulates the commitment cost. The incorporation of both the commitment and reconstruction losses synergistically optimizes gradient propagation, leading to improved learning efficacy.\n\n\\end{enumerate}\n\nFurthermore, the integration of a rotation mechanism based on Householder transformations within the Vector Quantizer significantly enhances the alignment of quantized vectors with the underlying data structure. This optimization mitigates misalignment issues that can arise during training, leading to improved representation quality and training efficiency.\n\nOur experimental results validate the effectiveness of our gradient propagation strategy. For instance, when evaluated on the CIFAR-10 dataset, our system achieved a reconstruction loss of 0.0098 and a codebook usage of 96.8\\%. In contrast, standard Vector Quantization Variational Autoencoders (VQ-VAE) reported a reconstruction loss of 0.0189 with a codebook usage of only 78.3\\%. Moreover, when applied to the more extensive ImageNet dataset, which contains over a million samples, our framework consistently outperformed existing models, evidencing the benefits of our proposed methodology.\n\nIn summary, our approach harnesses the straight-through estimator and a custom gradient strategy to adeptly navigate the complexities of non-differentiable operations. This innovative methodology not only bolsters the robustness of our model but also enhances its capacity for effective representation learning while maintaining theoretical consistency across the optimization landscape. The substantial improvements in representation quality and learning dynamics underscore the competitiveness of our method within the realm of neural discrete representation learning.\n```"
}